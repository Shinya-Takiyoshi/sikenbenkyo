■抽象メソッド
抽象メソッドは暗黙的にpublicです。
理由：インタフェースは外部に公開することを目的としているため
インタフェースのメソッドの実装ではアクセス修飾子を厳しくできない。

■拡張for文のnull
・nullで落ちないパターン
　配列の値にnullが格納されている時
 　→アドレスを参照しているだけなので落ちない。
 ・nullで落ちるパターン
 　インスタンスの値がnullのものにアクセスしようとした時
  　→取り出すときにエラーになる。
   
■ラムダ式
 (ラムダ式に渡そうとしている引数)->{ラムダ式}
 [ラムダ式に渡そうとしている引数]は、[ラムダ式]内でしか使用ができないため、[ラムダ式]外で使おうとするとコンパイラは検知してエラーにする。
 
■抽象メソッドの実装
 具象クラスと抽象クラスはどれかまず確認する。
 インタフェースで定義された抽象メソッドは継承先で定義が必要。
 抽象クラスは実装がなくてもいい。具象クラスで実装されているかが重要。
 
■staticフィールド
 staticな変数は、インスタンス単位ではなく、クラス単位で値保持を管理している。
 今回はsysoのタイミングの問題。
 
■配列の参照
 インスタンスの代入はコピーと違い、同じ参照先を見ているから一緒になる。
 今回は初期化した宣言は、代入の値で上書きされている。
 
■ガベージコレクション
 参照先が残っているかどうか。
 変数がどのインスタンスを参照しているか。
 a ← cの参照を代入
 c ← bの参照を代入
 b ← nullを代入
 上記の場合、aだけが参照されているものが無いため、ガベージコレクションの対象となる。
 
■変数のスコープ
 変数がどこまで使えるかを確認する。
 
■サブコンストラクタの呼出
 サブクラスのコンストラクタ
 下記のように、スーパークラスのデフォルトコンストラクタが自動的にコンパイルされる。
 ※明示的にスーパークラスのコンストラクタを指定した場合は別。
 method(){
 super(); // 自動で追加される
 // some code
 }
 
■非検査例外/検査例外
非検査例外 →RuntimeException
検査例外をスローする
 throwだけだと、上位メソッドまで戻らない。
 throwsを指定して初めて上位メソッドに到達する。
 検査例外を検査する方法は2パターン
 ①throwsで上位に投げる
 ②catchで拾う
