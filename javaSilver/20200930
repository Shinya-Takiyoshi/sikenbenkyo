■配列の参照情報の代入
A配列からB配列に代入した場合、
A配列の値を変更した箇所がB配列でもコピーされる。
intを取り出すときは計算される。

■代入演算子と論理演算子の優先順位
代入演算子を表示に使えないと思ったが代入した結果が表示される。

■定数について
上書きはできないが、コンストラクタで初期化はできる。
※今回初期値を設定していないため
TODO：実機で確認する。

■オブジェクトへのアクセスについて
同じインスタンスが入っていたとして
片方がnullにされても、代入元は影響が無い
MyClass mc = new MyClass();
MyClass mc2 = mc;
mc2 = null;
mcのインスタンスは生きている。

■for文について
for(①変数の初期化;②ループ継続条件;③増減数;)
③は省略できる。
i++ - ++i < 0;
iに0を代入
0++ - ++0 < 0;
手順1. 0++で後置+1
手順2. ++0で前置+1
手順3. 合計+2
手順4. 0 - 2 < 0;
手順5.  - 2 < 0;

iに2を代入
2++ - ++2 < 0;
手順1. 2++で後置+1
手順2. ++2で前置+1
手順3. 合計+4
手順4. 2 - 4 < 0;
手順5.  - 2 < 0;

結果が同じため無限ループする。

■インタフェースの実装
・インタフェースで定義したメソッドは全てオーバーライドする必要がある
・オーバーライドしない場合は、抽象クラスとして定義する

■二次元配列
int ary[][]　= {{0},{1,2,3},{4,5},{6,7,8,9}}
{}の枠のネストによって次元が増える。
※forで二重に回している前提
ary.length →1次元数に対しての数　この場合1
ary[i].length →2次元数に対しての数　この場合
ary[0] = {0}
ary[1] = {1,2,3}
ary[2] = {4,5}
ary[3] = {6,7,8,9}

■例外をスローするオーバーライドについて
Fruit f = new Orange(); // 参照型はFruit、インスタンス生成はOrange
f.foo();
この場合はOrangeのfoo()が呼び出されるが //実行時点
Fruitのfoo()がExceptionを発生させるようにしている。 //呼び出し時点
そのため、Exceptionの例外処理をcatchする処理が無いとエラーになる。


